<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Random.html">
<link rel="next" href="Set.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Arg" rel="Chapter" href="Arg.html">
<link title="Arith_flags" rel="Chapter" href="Arith_flags.html">
<link title="Arith_status" rel="Chapter" href="Arith_status.html">
<link title="Array" rel="Chapter" href="Array.html">
<link title="ArrayLabels" rel="Chapter" href="ArrayLabels.html">
<link title="Buffer" rel="Chapter" href="Buffer.html">
<link title="Callback" rel="Chapter" href="Callback.html">
<link title="CamlinternalMod" rel="Chapter" href="CamlinternalMod.html">
<link title="CamlinternalOO" rel="Chapter" href="CamlinternalOO.html">
<link title="Char" rel="Chapter" href="Char.html">
<link title="Complex" rel="Chapter" href="Complex.html">
<link title="Dbm" rel="Chapter" href="Dbm.html">
<link title="Digest" rel="Chapter" href="Digest.html">
<link title="Dynlink" rel="Chapter" href="Dynlink.html">
<link title="Event" rel="Chapter" href="Event.html">
<link title="Filename" rel="Chapter" href="Filename.html">
<link title="Format" rel="Chapter" href="Format.html">
<link title="Gc" rel="Chapter" href="Gc.html">
<link title="Genlex" rel="Chapter" href="Genlex.html">
<link title="Graphics" rel="Chapter" href="Graphics.html">
<link title="GraphicsX11" rel="Chapter" href="GraphicsX11.html">
<link title="Hashtbl" rel="Chapter" href="Hashtbl.html">
<link title="Int32" rel="Chapter" href="Int32.html">
<link title="Int64" rel="Chapter" href="Int64.html">
<link title="Int_misc" rel="Chapter" href="Int_misc.html">
<link title="Lazy" rel="Chapter" href="Lazy.html">
<link title="Lexing" rel="Chapter" href="Lexing.html">
<link title="List" rel="Chapter" href="List.html">
<link title="ListLabels" rel="Chapter" href="ListLabels.html">
<link title="Map" rel="Chapter" href="Map.html">
<link title="Marshal" rel="Chapter" href="Marshal.html">
<link title="MoreLabels" rel="Chapter" href="MoreLabels.html">
<link title="Mutex" rel="Chapter" href="Mutex.html">
<link title="Nat" rel="Chapter" href="Nat.html">
<link title="Nativeint" rel="Chapter" href="Nativeint.html">
<link title="Obj" rel="Chapter" href="Obj.html">
<link title="Oo" rel="Chapter" href="Oo.html">
<link title="Parsing" rel="Chapter" href="Parsing.html">
<link title="Pervasives" rel="Chapter" href="Pervasives.html">
<link title="Printexc" rel="Chapter" href="Printexc.html">
<link title="Printf" rel="Chapter" href="Printf.html">
<link title="Queue" rel="Chapter" href="Queue.html">
<link title="Random" rel="Chapter" href="Random.html">
<link title="Scanf" rel="Chapter" href="Scanf.html">
<link title="Set" rel="Chapter" href="Set.html">
<link title="Sort" rel="Chapter" href="Sort.html">
<link title="Stack" rel="Chapter" href="Stack.html">
<link title="StdLabels" rel="Chapter" href="StdLabels.html">
<link title="Str" rel="Chapter" href="Str.html">
<link title="Stream" rel="Chapter" href="Stream.html">
<link title="String" rel="Chapter" href="String.html">
<link title="StringLabels" rel="Chapter" href="StringLabels.html">
<link title="Sys" rel="Chapter" href="Sys.html">
<link title="Unix" rel="Chapter" href="Unix.html">
<link title="Weak" rel="Chapter" href="Weak.html"><link title="Functional input with format strings." rel="Section" href="#6_Functionalinputwithformatstrings">
<link title="Formatted input functions" rel="Section" href="#6_Formattedinputfunctions">
<title>Scanf</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Random.html" title="Random">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Set.html" title="Set">Next</a>
</div>
<h1>Module <a href="type_Scanf.html">Scanf</a></h1>

<pre><span id="MODULEScanf"><span class="keyword">module</span> Scanf</span>: <code class="code">sig</code> <a href="Scanf.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<p>Formatted input functions.</p>
</div>
</div>
<hr width="100%">
<h7 id="6_Functionalinputwithformatstrings">Functional input with format strings.</h7><p>The formatted input functions provided by module <code class="code">Scanf</code> are functionals
    that apply their function argument to the values they read in the input.
    The specification of the values to read is simply given by a format string
    (the same format strings as those used to print material using module
    <a href="Printf.html"><code class="code">Printf</code></a> or module <a href="Format.html"><code class="code">Format</code></a>).</p>

<p>As an example, consider the formatted input function <code class="code">scanf</code> that reads
    from standard input; a typical call to <code class="code">scanf</code> is simply <code class="code">scanf fmt f</code>,
    meaning that <code class="code">f</code> should be applied to the arguments read according to the
    format string <code class="code">fmt</code>. For instance, if <code class="code">f</code> is defined as <code class="code">let f x = x + 1</code>,
    then <code class="code">scanf "%d" f</code> will read a decimal integer <code class="code">i</code> from <code class="code">stdin</code> and return
    <code class="code">f i</code>; thus, if we enter <code class="code">41</code> at the keyboard, <code class="code">scanf "%d" f</code> evaluates to
    <code class="code">42</code>.</p>

<p>This module provides general formatted input functions that read from any
    kind of input, including strings, files, or anything that can return
    characters.
    Hence, a typical call to a formatted input function <code class="code">bscan</code> is
    <code class="code">bscan ib fmt f</code>, meaning that <code class="code">f</code> should be applied to the arguments
    read from input <code class="code">ib</code>, according to the format string <code class="code">fmt</code>.</p>

<p>The Caml scanning facility is reminiscent of the corresponding C feature.
    However, it is also largely different, simpler, and yet more powerful: the
    formatted input functions are higher-order functionals and the parameter
    passing mechanism is simply the regular function application not the
    variable assigment based mechanism which is typical of formatted input in
    imperative languages; the format strings also feature useful additions to
    easily define complex tokens; as expected of a functional programming
    language feature, the formatted input functions support polymorphism, in
    particular arbitrary interaction with polymorphic user-defined scanners.
    Furthermore, the Caml formatted input facility is fully type-checked at
    compile time.</p>

<pre><span id="MODULEScanning"><span class="keyword">module</span> <a href="Scanf.Scanning.html">Scanning</a></span>: <code class="code">sig</code> <a href="Scanf.Scanning.html">..</a> <code class="code">end</code></pre><div class="info">
<p>Scanning buffers</p>

</div>

<pre><span id="EXCEPTIONScan_failure"><span class="keyword">exception</span> Scan_failure</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info ">
<div class="info-desc">
<p>The exception raised by formatted input functions when the input cannot be
    read according to the given format.</p>
</div>
</div>

<pre><span id="TYPEscanner"><span class="keyword">type</span> <code class="type">('a, 'b, 'c, 'd)</code> scanner</span> = <code class="type">('a, <a href="Scanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a>, 'b, 'c, 'a -> 'd, 'd) Stdlib.format6 -> 'c</code> </pre>
<div class="info ">
<div class="info-desc">
<p>The type of formatted input scanners: <code class="code">('a, 'b, 'c, 'd) scanner</code> is the
    type of a formatted input function that reads from some scanning buffer
    according to some format string; more precisely, if <code class="code">scan</code> is some
    formatted input function, then <code class="code">scan ib fmt f</code> applies <code class="code">f</code> to the arguments
    specified by the format string <code class="code">fmt</code>, when <code class="code">scan</code> has read those arguments
    from some scanning buffer <code class="code">ib</code>.</p>

<p>For instance, the <code class="code">scanf</code> function below has type <code class="code">('a, 'b, 'c, 'd)
    scanner</code>, since it is a formatted input function that reads from <code class="code">stdib</code>:
    <code class="code">scanf fmt f</code> applies <code class="code">f</code> to the arguments specified by <code class="code">fmt</code>, reading
    those arguments from <code class="code">stdin</code> as expected.</p>

<p>If the format <code class="code">fmt</code> has some <code class="code">%r</code> indications, the corresponding input
    functions must be provided before the <code class="code">f</code> argument. For instance, if
    <code class="code">read_elem</code> is an input function for values of type <code class="code">t</code>, then <code class="code">bscanf ib
    "%r;" read_elem f</code> reads a value of type <code class="code">t</code> followed by a <code class="code">';'</code>
    character.</p>
</div>
</div>

<h7 id="6_Formattedinputfunctions">Formatted input functions</h7>
<pre><span id="VALbscanf"><span class="keyword">val</span> bscanf</span> : <code class="type"><a href="Scanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> -> ('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">bscanf ib fmt r1 ... rN f</code> reads arguments for the function <code class="code">f</code> from the
   scanning buffer <code class="code">ib</code> according to the format string <code class="code">fmt</code>, and applies <code class="code">f</code>
   to these values.
   The result of this call to <code class="code">f</code> is returned as the result of <code class="code">bscanf</code>.
   For instance, if <code class="code">f</code> is the function <code class="code">fun s i -&gt; i + 1</code>, then
   <code class="code">Scanf.sscanf "x = 1" "%s = %i" f</code> returns <code class="code">2</code>.</p>

<p>Arguments <code class="code">r1</code> to <code class="code">rN</code> are user-defined input functions that read the
   argument corresponding to a <code class="code">%r</code> conversion.</p>

<p>The format is a character string which contains three types of
   objects:</p>
<ul>
<li>plain characters, which are simply matched with the characters of the
   input,</li>
<li>conversion specifications, each of which causes reading and conversion of
   one argument for <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<p>Among plain characters the space character (ASCII code 32) has a
   special meaning: it matches ``whitespace'', that is any number of tab,
   space, line feed and carriage return characters. Hence, a space in the format
   matches any amount of whitespace in the input.</p>

<p>Conversion specifications consist in the <code class="code">%</code> character, followed by
   an optional flag, an optional field width, and followed by one or
   two conversion characters. The conversion characters and their
   meanings are:</p>

<ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
     (usual input formats for hexadecimal (<code class="code">0x[d]+</code> and <code class="code">0X[d]+</code>),
      octal (<code class="code">0o[d]+</code>), and binary <code class="code">0b[d]+</code> notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer.</li>
<li><code class="code">o</code>: reads an unsigned octal integer.</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible,
     until the next white space, the next scanning indication, or the
     end-of-input is reached. Hence, this conversion always succeeds:
     it returns an empty string if the bounding condition holds
     when the scan begins.</li>
<li><code class="code">S</code>: reads a delimited string argument (delimiters and special
     escaped characters follow the lexical conventions of Caml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
     without reading it, specify a null field width, i.e. use
     specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width
     specification is greater than 1.</li>
<li><code class="code">C</code>: reads a single delimited character (delimiters and special
     escaped characters follow the lexical conventions of Caml).</li>
<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed
     floating-point number in decimal notation, in the style <code class="code">dddd.ddd
     e/E+-dd</code>.</li>
<li><code class="code">F</code>: reads a floating point number according to the lexical
     conventions of Caml (hence the decimal point is mandatory if the
     exponent part is not mentioned).</li>
<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>
<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use
     in new programs).</li>
<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to
     the format specified by the second letter (decimal, hexadecimal, etc).</li>
<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to
     the format specified by the second letter.</li>
<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to
     the format specified by the second letter.</li>
<li><code class="code">[ range ]</code>: reads characters that matches one of the characters
     mentioned in the range of characters <code class="code">range</code> (or not mentioned in
     it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be
     empty, if the next input character does not match the range. The set of
     characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.
     Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number
     or an empty string if no decimal digit is found; similarly,
     <code class="code">%[\\048-\\057\\065-\\070]</code> returns a string of hexadecimal digits.
     If a closing bracket appears in a range, it must occur as the
     first character of the range (or just after the <code class="code">^</code> in case of
     range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and
     <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.</li>
<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input function and
     applies it to the scanning buffer <code class="code">ib</code> to read the next argument. The
     input function <code class="code">ri</code> must therefore have type <code class="code">Scanning.scanbuf -&gt; 'a</code> and
     the argument read has type <code class="code">'a</code>.</li>
<li><code class="code">{ fmt %}</code>: reads a format string argument to the format
     specified by the internal format <code class="code">fmt</code>. The format string to be
     read must have the same type as the internal format <code class="code">fmt</code>.
     For instance, "%{%i%}" reads any format string that can read a value of
     type <code class="code">int</code>; hence <code class="code">Scanf.sscanf "fmt:\\\"number is %u\\\"" "fmt:%{%i%}"</code>
     succeeds and returns the format string <code class="code">"number is %u"</code>.</li>
<li><code class="code">\( fmt %\)</code>: scanning format substitution.
     Reads a format string to replace <code class="code">fmt</code>. The format string read
     must have the same type as <code class="code">fmt</code>.</li>
<li><code class="code">l</code>: returns the number of lines read so far.</li>
<li><code class="code">n</code>: returns the number of characters read so far.</li>
<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>
<li><code class="code">!</code>: matches the end of input condition.</li>
<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>
</ul>
<p>Following the <code class="code">%</code> character that introduces a conversion, there may be
   the special flag <code class="code">_</code>: the conversion that follows occurs as usual,
   but the resulting value is discarded.
   For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, then
   <code class="code">Scanf.sscanf "x = 1" "%_s = %i" f</code> returns <code class="code">2</code>.</p>

<p>The field width is composed of an optional integer literal
   indicating the maximal width of the token to read.
   For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;
   <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\\000-\\255]</code>
   returns the next 8 characters (or all the characters still available,
   if fewer than 8 characters are available in the input).</p>

<p>Scanning indications appear just after the string conversions <code class="code">%s</code>
   and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning
   indication is introduced by a <code class="code">@</code> character, followed by some
   constant character <code class="code">c</code>. It means that the string token should end
   just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>
   character is encountered, the string token spreads as much as
   possible. For instance, <code class="code">"%s@\t"</code> reads a string up to the next
   tab character or to the end of input. If a scanning
   indication <code class="code">@c</code> does not follow a string conversion, it is treated
   as a plain <code class="code">c</code> character.</p>

<p>Raise <code class="code">Scanf.Scan_failure</code> if the input does not match the format.</p>

<p>Raise <code class="code">Failure</code> if a conversion to a number is not possible.</p>

<p>Raise <code class="code">End_of_file</code> if the end of input is encountered while some more
   characters are needed to read the current conversion specification.
   As a consequence, scanning a <code class="code">%s</code> conversion never raises exception
   <code class="code">End_of_file</code>: if the end of input is reached the conversion succeeds and
   simply returns the characters read so far, or <code class="code">""</code> if none were read.</p>

<p>Raise <code class="code">Invalid_argument</code> if the format string is invalid.</p>

<p>Notes:</p>

<ul>
<li>the scanning indications introduce slight differences in the
   syntax of <code class="code">Scanf</code> format strings compared to those used by the
   <code class="code">Printf</code> module. However, scanning indications are similar to those
   of the <code class="code">Format</code> module; hence, when producing formatted text to be
   scanned by <code class="code">!Scanf.bscanf</code>, it is wise to use printing functions
   from <code class="code">Format</code> (or, if you need to use functions from <code class="code">Printf</code>,
   banish or carefully double check the format strings that contain
   <code class="code">'@'</code> characters).</li>
</ul>
<ul>
<li>in addition to relevant digits, <code class="code">'_'</code> characters may appear
   inside numbers (this is reminiscent to the usual Caml lexical
   conventions). If stricter scanning is desired, use the range
   conversion facility instead of the number conversions.</li>
</ul>
<ul>
<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical
   analysis and parsing. If it appears not expressive enough for your
   needs, several alternative exists: regular expressions (module
   <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,
   <code class="code">ocamlyacc</code>-generated parsers.</li>
</ul>
</div>
</div>

<pre><span id="VALfscanf"><span class="keyword">val</span> fscanf</span> : <code class="type">Stdlib.in_channel -> ('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but reads from the given channel.</p>

<p>Warning: since all formatted input functions operate from a scanning
    buffer, be aware that each <code class="code">fscanf</code> invocation must allocate a new
    fresh scanning buffer (unless you make careful use of partial
    application). Hence, there are chances that some characters seem
    to be skipped (in fact they are pending in the previously used
    scanning buffer). This happens in particular when calling <code class="code">fscanf</code> again
    after a scan involving a format that necessitated some look ahead
    (such as a format that ends by skipping whitespace in the input).</p>

<p>To avoid confusion, consider using <code class="code">bscanf</code> with an explicitly
    created scanning buffer. Use for instance <code class="code">Scanning.from_file f</code>
    to allocate the scanning buffer reading from file <code class="code">f</code>.</p>

<p>This method is not only clearer it is also faster, since scanning
    buffers to files are optimized for fast buffered reading.</p>
</div>
</div>

<pre><span id="VALsscanf"><span class="keyword">val</span> sscanf</span> : <code class="type">string -> ('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but reads from the given string.</p>
</div>
</div>

<pre><span id="VALscanf"><span class="keyword">val</span> scanf</span> : <code class="type">('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but reads from the predefined scanning
    buffer <a href="Scanf.Scanning.html#VALstdib"><code class="code">Scanf.Scanning.stdib</code></a> that is connected to <code class="code">stdin</code>.</p>
</div>
</div>

<pre><span id="VALkscanf"><span class="keyword">val</span> kscanf</span> : <code class="type"><a href="Scanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> -><br>       (<a href="Scanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> -> exn -> 'd) -> ('a, 'b, 'c, 'd) <a href="Scanf.html#TYPEscanner">scanner</a></code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but takes an additional function argument
  <code class="code">ef</code> that is called in case of error: if the scanning process or
  some conversion fails, the scanning function aborts and calls the
  error handling function <code class="code">ef</code> with the scanning buffer and the
  exception that aborted the scanning process.</p>
</div>
</div>

<pre><span id="VALbscanf_format"><span class="keyword">val</span> bscanf_format</span> : <code class="type"><a href="Scanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> -><br>       ('a, 'b, 'c, 'd, 'e, 'f) Stdlib.format6 -><br>       (('a, 'b, 'c, 'd, 'e, 'f) Stdlib.format6 -> 'g) -> 'g</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">bscanf_format ib fmt f</code> reads a format string token from the scannning
  buffer <code class="code">ib</code>, according to the given format string <code class="code">fmt</code>, and applies <code class="code">f</code> to
  the resulting format string value.
  Raise <code class="code">Scan_failure</code> if the format string value read doesn't have the
  same type as <code class="code">fmt</code>.</p>
</div>
</div>

<pre><span id="VALsscanf_format"><span class="keyword">val</span> sscanf_format</span> : <code class="type">string -><br>       ('a, 'b, 'c, 'd, 'e, 'f) Stdlib.format6 -><br>       (('a, 'b, 'c, 'd, 'e, 'f) Stdlib.format6 -> 'g) -> 'g</code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Scanf.html#VALbscanf_format"><code class="code">Scanf.bscanf_format</code></a>, but reads from the given string.</p>
</div>
</div>

<pre><span id="VALformat_from_string"><span class="keyword">val</span> format_from_string</span> : <code class="type">string -><br>       ('a, 'b, 'c, 'd, 'e, 'f) Stdlib.format6 -><br>       ('a, 'b, 'c, 'd, 'e, 'f) Stdlib.format6</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">format_from_string s fmt</code> converts a string argument to a format string,
  according to the given format string <code class="code">fmt</code>.
  Raise <code class="code">Scan_failure</code> if <code class="code">s</code>, considered as a format string, doesn't
  have the same type as <code class="code">fmt</code>.</p>
</div>
</div>
</body></html>
