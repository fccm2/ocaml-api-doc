<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="Up" href="Domain.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Arg" rel="Chapter" href="Arg.html">
<link title="Array" rel="Chapter" href="Array.html">
<link title="ArrayLabels" rel="Chapter" href="ArrayLabels.html">
<link title="Atomic" rel="Chapter" href="Atomic.html">
<link title="Bigarray" rel="Chapter" href="Bigarray.html">
<link title="Bool" rel="Chapter" href="Bool.html">
<link title="Buffer" rel="Chapter" href="Buffer.html">
<link title="Bytes" rel="Chapter" href="Bytes.html">
<link title="BytesLabels" rel="Chapter" href="BytesLabels.html">
<link title="Callback" rel="Chapter" href="Callback.html">
<link title="Char" rel="Chapter" href="Char.html">
<link title="Complex" rel="Chapter" href="Complex.html">
<link title="Digest" rel="Chapter" href="Digest.html">
<link title="Domain" rel="Chapter" href="Domain.html">
<link title="Dynarray" rel="Chapter" href="Dynarray.html">
<link title="Dynlink" rel="Chapter" href="Dynlink.html">
<link title="Dynlink_types" rel="Chapter" href="Dynlink_types.html">
<link title="Effect" rel="Chapter" href="Effect.html">
<link title="Either" rel="Chapter" href="Either.html">
<link title="Ephemeron" rel="Chapter" href="Ephemeron.html">
<link title="Event" rel="Chapter" href="Event.html">
<link title="Filename" rel="Chapter" href="Filename.html">
<link title="Float" rel="Chapter" href="Float.html">
<link title="Fun" rel="Chapter" href="Fun.html">
<link title="Gc" rel="Chapter" href="Gc.html">
<link title="Hashtbl" rel="Chapter" href="Hashtbl.html">
<link title="In_channel" rel="Chapter" href="In_channel.html">
<link title="Int" rel="Chapter" href="Int.html">
<link title="Int32" rel="Chapter" href="Int32.html">
<link title="Int64" rel="Chapter" href="Int64.html">
<link title="Lazy" rel="Chapter" href="Lazy.html">
<link title="Lexing" rel="Chapter" href="Lexing.html">
<link title="List" rel="Chapter" href="List.html">
<link title="ListLabels" rel="Chapter" href="ListLabels.html">
<link title="Map" rel="Chapter" href="Map.html">
<link title="Marshal" rel="Chapter" href="Marshal.html">
<link title="Mutex" rel="Chapter" href="Mutex.html">
<link title="Nativeint" rel="Chapter" href="Nativeint.html">
<link title="Obj" rel="Chapter" href="Obj.html">
<link title="Oo" rel="Chapter" href="Oo.html">
<link title="Option" rel="Chapter" href="Option.html">
<link title="Out_channel" rel="Chapter" href="Out_channel.html">
<link title="Parsing" rel="Chapter" href="Parsing.html">
<link title="Printexc" rel="Chapter" href="Printexc.html">
<link title="Printf" rel="Chapter" href="Printf.html">
<link title="Queue" rel="Chapter" href="Queue.html">
<link title="Random" rel="Chapter" href="Random.html">
<link title="Result" rel="Chapter" href="Result.html">
<link title="Scanf" rel="Chapter" href="Scanf.html">
<link title="Semaphore" rel="Chapter" href="Semaphore.html">
<link title="Seq" rel="Chapter" href="Seq.html">
<link title="Set" rel="Chapter" href="Set.html">
<link title="Stack" rel="Chapter" href="Stack.html">
<link title="StdLabels" rel="Chapter" href="StdLabels.html">
<link title="Std_exit" rel="Chapter" href="Std_exit.html">
<link title="Str" rel="Chapter" href="Str.html">
<link title="String" rel="Chapter" href="String.html">
<link title="StringLabels" rel="Chapter" href="StringLabels.html">
<link title="Sys" rel="Chapter" href="Sys.html">
<link title="Type" rel="Chapter" href="Type.html">
<link title="Uchar" rel="Chapter" href="Uchar.html">
<link title="Unit" rel="Chapter" href="Unit.html">
<link title="Unix" rel="Chapter" href="Unix.html">
<link title="Weak" rel="Chapter" href="Weak.html"><title>Domain.DLS</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Domain.html" title="Domain">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Domain.DLS.html">Domain.DLS</a></h1>

<pre><span id="MODULEDLS"><span class="keyword">module</span> DLS</span>: <code class="code">sig</code> <a href="Domain.DLS.html">..</a> <code class="code">end</code></pre><hr width="100%">
<p>Domain-local Storage</p>

<pre><span id="TYPEkey"><span class="keyword">type</span> <code class="type">'a</code> key</span> </pre>
<div class="info ">
<div class="info-desc">
<p>Type of a DLS key</p>
</div>
</div>


<pre><span id="VALnew_key"><span class="keyword">val</span> new_key</span> : <code class="type">?split_from_parent:('a -&gt; 'a) -&gt; (unit -&gt; 'a) -&gt; 'a <a href="Domain.DLS.html#TYPEkey">key</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">new_key f</code> returns a new key bound to initialiser <code class="code">f</code> for accessing
,        domain-local variables.</p>

<p>If <code class="code">split_from_parent</code> is not provided, the value for a new
        domain will be computed on-demand by the new domain: the first
        <code class="code">get</code> call will call the initializer <code class="code">f</code> and store that value.</p>

<p><b>Warning.</b> <code class="code">f</code> may be called several times if another call
        to <code class="code">get</code> occurs during initialization on the same domain. Only
        the 'first' value computed will be used, the other now-useless
        values will be discarded. Your initialization function should
        support this situation, or contain logic to detect this case
        and fail.</p>

<p>If <code class="code">split_from_parent</code> is provided, spawning a domain will
        derive the child value (for this key) from the parent
        value. This computation happens in the parent domain and it
        always happens, regardless of whether the child domain will
        use it.
        If the splitting function is expensive or requires
        child-side computation, consider using <code class="code">'a Lazy.t key</code>:</p>

<pre class="codepre"><code class="code">        let init () = ...

        let split_from_parent parent_value =
          ... parent-side computation ...;
          lazy (
            ... child-side computation ...
          )

        let key = Domain.DLS.new_key ~split_from_parent init

        let get () = Lazy.force (Domain.DLS.get key)
        </code></pre>
<p>In this case a part of the computation happens on the child
        domain; in particular, it can access <code class="code">parent_value</code>
        concurrently with the parent domain, which may require
        explicit synchronization to avoid data races.</p>
</div>
</div>

<pre><span id="VALget"><span class="keyword">val</span> get</span> : <code class="type">'a <a href="Domain.DLS.html#TYPEkey">key</a> -&gt; 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">get k</code> returns <code class="code">v</code> if a value <code class="code">v</code> is associated to the key <code class="code">k</code> on
        the calling domain's domain-local state. Sets <code class="code">k</code>'s value with its
        initialiser and returns it otherwise.</p>
</div>
</div>

<pre><span id="VALset"><span class="keyword">val</span> set</span> : <code class="type">'a <a href="Domain.DLS.html#TYPEkey">key</a> -&gt; 'a -&gt; unit</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">set k v</code> updates the calling domain's domain-local state to associate
        the key <code class="code">k</code> with value <code class="code">v</code>. It overwrites any previous values associated
        to <code class="code">k</code>, which cannot be restored later.</p>
</div>
</div>
</body></html>
